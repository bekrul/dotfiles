#/bin/bash
################################################################################
# vmake [all|changeset|clean|err|info|install|full_install|label|tags|-h|--help]
# 
# 2017 - Ben Krulewitch 
#
# Overview
#  run builds & generate tag, error, and build info from bash or vim.  
#  (vimmake)
#
# Requirements
#  * Execute from directory with project file (or Makefile)
#  * See dotfiles install notes for vim configuration
#  * project name is same as project directory, or specified in .vmake_profile
#  * vmake's directory is part of $PATH
#
# Project Types 
#  .project 		 	- 	Eclipse, Code Composer 6 		(Mac, PC, Linux?)
#  .vcproj 			 	- 	Microsoft Visual Studio 2008 	(PC)
#  .isArduinoProject	-	Arduino 						(Mac)
#  						-	create blank .isArduinoProject file to mark dir for use with vmake
#  Makefile 			-	gnu make
#
# Rules
#  * tags regenerated by all rules.  
#  * error lists generated by all rules invoking compiler.
# 
#  all 		- build project (default rule)
#  tags 	- don't build, regenerate tags used by vim 
#  clean	- erase files generated by build 
#  info		- log details on build (not supported for all project types)
#
# Settings for specific projects
# .vmake_profile 		- optional customization file. 
#                         refer to dotfiles/bash/bin/default.vmake_profile 
#
# Output Files 
#  [compiler output]	- depends on project type
#  vimbuild.err			- error descriptions tagged for vim
#  vimctags				- code identifiers tagged for vim
#  buildinfo			- dir with log and details outputted by rule "info"
#
################################################################################
# CCS6 Specific
# 
# Rules 
#  err				- regenerate errorlist without invoking build
#  install			- install fw, via msp-fet hw and MSP430Flasher.exe
#  full_install		- clear fram and then install fw, via msp-fet hw and MSP430Flasher.exe
#  changeset 		- find and save changeset of sources (used by rule "info")
#  info 			- build project, generate build info on success:
#  		  	  	  	  $ProjDir/buildinfo/<UniqDirName>  
#  if none of the above rules are present, rules are passed to the compiler
#
################################################################################
# VS2008 Specific 
#
#  The only rule accepted is "clean", otherwise builds the Debug configuration,
#  and generates vimctags and vimbuild.err files.  No buildinfo generated.
#
################################################################################


################################################################################
# 'pre' main
################################################################################

# exit script if it encounters an uninitialized variable
set -o nounset

# exit script if any command returns a nonzero value
set -o errexit

# print each command to stdout before executing it
#set -v

# print each expanded command to stdout before executing it
#set -x
# Note: this script uses 'set -x' and 'set +x' below, comment out below to use here

################################################################################
# function declarations
################################################################################

usage () 
{
    cmdName=$(basename "$0")
    echo "Usage: $cmdName [options] [rules]"
    echo "Options:"
    echo "-h, --help                         		Print this message and exit."
	# not implemented...	
	#echo "-C DIRECTORY, --directory DIRECTORY		Change to DIRECTORY before doing anything."
	echo "-L LABEL									build and generate buildinfo with LABEL, setting LABEL for future builds."
	echo "-l LABEL									build and generate buildinfo with LABEL."
	echo "											buildinfo saved to ./buildinfo/<changeset>_<LABEL>_<X>"
	echo "Rules:"
    echo "All rules are passed along to the make script, including 'clean' and 'all' except for:"
    echo "err 			-  generate vimbuild.err error list file for the project, overwriting file in project directory."
    echo "tags			-  generate vimctags file for the project, overwriting file in project directory."
   	echo "info			-  generate buildinfo, tagged with label and changeset." 
	echo "changeset		-  cache local changeset searching source tree for file with latest changeset."
	echo "label			-  set default label used by info rule."
	echo "CCS projects only:" 
	echo "install		-  install latest built firmware onto mcu attached to MSP-FET, and reset the mcu." 
	echo "full_install	-  erase fram and install latest built firmware onto mcu attached to MSP-FET, and reset the mcu." 
	echo "If no rule is specified, default behavior is 'all'."  
}

parseArgs()
{
    MakeRules=
	BuildLabel=

	# default values for flags set by command line params
	FlgGenBuildInfo=false
    FlgGenTags=false
    FlgGenErrs=true
    FlgGenErrsOnly=false
    FlgMakeAll=false
    FlgMakeClean=false
    FlgMakeInstall=false
	FlgEraseFram=false
	FlgSetLabel=false
	FlgSetChangeset=false

    #echo "parseArgs..."
    #echo "NumArgs: $#"
    #echo "Args: $@"

    # parse all arguments with format '-flag value', ie '-x xxxxx', or '-xx x'
    UnhandledArgs=()
    while [[ $# > 1 ]]
    do
        key="$1"
        case $key in
                label|-L)
                BuildLabel="$2"
				FlgGenBuildInfo=true
				FlgSetLabel=true
                shift # past argument
            ;;
                -l)
                BuildLabel="$2"
				FlgGenBuildInfo=true
    			FlgGenErrs=false
                shift # past argument
            ;;
            	*)
                # unknown option, add to MakeRules
                UnhandledArgs+=($key) 
                # no shift, as next argument could be a key 
                #shift # past argument
            ;;
# not implemented
#                -C|--directory)
#                ProjDir="$2"
#                shift # past argument
#            ;;
        esac
        shift # past argument or value
    done

    # combine arguments not yet handled into a singla array for further processing 
    if [[ -z "${UnhandledArgs+x}" ]]; then
        RemainingArgs="$@"
    else
        RemainingArgs=("${UnhandledArgs[@]}" "$@") 
    fi

    #echo "parsed all '-flag value' arguments"
    #echo "RemainingArgs: ${RemainingArgs[*]}"

    # now parse all arguments with format '-flag', ie -xxx
    UnhandledArgs=
    for key in "${RemainingArgs[@]}"
    do
        case $key in
        -h|--help)
            # print usage info and exit
            usage
            exit 0
        ;;
        all)
            FlgMakeAll=true
        ;;
        clean)
            FlgMakeClean=true
        ;;
        install)
            FlgMakeInstall=true
    		FlgGenErrs=false
        ;;
        full_install)
            FlgMakeInstall=true
            FlgEraseFram=true
    		FlgGenErrs=false
        ;;
        err)
            FlgGenErrsOnly=true
        ;;
        tags)
            FlgGenTags=true
    		FlgGenErrs=false
        ;;
        info)
            FlgGenBuildInfo=true
        ;;
        -s|changeset)
            FlgSetChangeset=true
    		FlgGenErrs=false
        ;;
        *)
            # unknown option, add to UnhandledArgs 
            UnhandledArgs="$UnhandledArgs $key" 
        ;;
        esac
    done
   
    #echo "parsed all '-flag' arguments"
    #echo "UnhandledArgs: $UnhandledArgs"
    
    # If UnhandledArgs contains only spaces, clear it
    if [[ -z "${UnhandledArgs// }" ]]; then
        UnhandledArgs=
    fi

	# remaining arguments treated as make rules
    if ! [[ -z "$UnhandledArgs" ]]; then
        MakeRules="$UnhandledArgs"
    fi

    # rules clean & all get removed above to set flags used with Visual Studio projects.  
	# put them back into $MakeRules here.  
    if [ "$FlgMakeClean" == true ]; then
        MakeRules=clean 
        #MakeRules="clean $MakeRules" 
    fi 

    if [ "$FlgMakeAll" == true ]; then
        MakeRules=all 
		# Note: too much hassle to allow passing in multiple rules at a time, 
		#  so not allowing it.  the following doesnt work on all compilers an systems.  
        #MakeRules="$MakeRules all" 
    fi 

    # If $MakeRules contains only spaces, default to target all
    if [[ -z "${MakeRules// }" ]]; then
        MakeRules=all
    fi


    #echo "ScriptPath = $ScriptPath"
    #echo "ProjDir = $ProjDir"
    #echo "MakeRules = $MakeRules"

	# shorthand way to implement parameters doesnt work as well
    #for i in "$@"
    #do
    #case $i in
    #    -C=*|--directory=*)
    #    ProjDir="${i#*=}"
    #    shift # past argument=value
    #    ;;
    #    *)
    #            # unknown option
    #    ;;
    #esac
    #done
	#
    #while getopts C:h: option; do 
    #    case "${option}" in 
    #        C) ProjDir=${OPTARG}
    #            ;; 
    #        h) echo "print usage info"
    #    esac 
    #done
}

################################################################################
# main execution 
################################################################################

# common env setup for vmake related scripts.  allows running certain subscripts individually.
#
# Note: ~/dotfiles/bash/bin must be part of $PATH.
source vmakeCommonSrc

echo "vmake - $ProjTypeString project type"

parseArgs "$@"

# already being inside project directory is requirement of these scripts
#cd "$ProjDir"

if [ "$FlgSetLabel" == true ]; then
	if [ "$IsCCSProj" == true ]; then
		# Note: this functionality can be pulled out of compiler specific script
		vmakeGenBuildInfoMsp.sh --savelabel "$BuildLabel"
	else
		echo "'vmake label' - unimplemented for this project type"
	fi
fi

# execute the rule 
#
# Note: rule specific scripts are executed and not sourced, so no variables set here are
#  passed in. They rely on vmakeCommonSrc and project dir for config.
#
if [ "$FlgGenTags" == true ]; then

    vmakeGenTagFile.sh 
    # create error file if none exists so vim doesnt generate error
    touch "$VMakeErrFileTmp" 

elif [ "$FlgSetChangeset" == true ]; then
	if [ "$IsCCSProj" == true ]; then
		# Note: this functionality can be pulled out of compiler specific script
		vmakeGenBuildInfoMsp.sh -s
	else
		echo "'vmake changeset' - option only supported for CCS6 projects, doing nothing"
	fi

elif [ "$FlgMakeInstall" == true ]; then

	if [ "$IsCCSProj" == true ]; then
		if [ "$FlgEraseFram" == true ]; then
			MspFlasherEraseArg=" -e ERASE_ALL"
		else
			MspFlasherEraseArg=" -e ERASE_MAIN"
		fi

		# print each expanded command to stdout before executing it
		#set -x
		#
        # test that hex file exists as unfortunately the ti script hangs if it does not
        if [ -f "${MspHexRelPath}" ]; then

            echo "$MSP_FLASHER_PATH" "$MspFlasherInstallArgs" "$MspFlasherEraseArg"
            # install latest built firmware onto device attached to MSP-FET, and reset the device.  
            eval "$MSP_FLASHER_PATH" "$MspFlasherInstallArgs" "$MspFlasherEraseArg"
        else
            echo "File does not exist: $MSP_FLASHER_PATH"
        fi
		#set +x
	else
		echo "'vmake install' - option only supported for CCS6 projects, doing nothing"
    fi

elif [ "$FlgGenErrsOnly" != true ]; then
	# general build rule

	if [ "$IsVSProj" == true ]; then
		
		# Run VS2008 cmd line compiler
		# Rules accepted:
		#  clean
		#  all (default)
		#
		#  any other rules passed in via command line are ignored

        VSMakeRule=/build 
        if [ "$FlgMakeClean" == true ]; then
            VSMakeRule=/clean
        fi

		# turn on output so user can see the command passed to compiler
        set -x 
        
		# delete error file, as this compiler appends errors instead of overwriting the file
        rm -f "$ProjDir/$VMakeErrFile"

        # execute visual studio command line build  
		#  ignore failure of command ( || true) - required as devenv returns error on failed build, but
		#  we want this script to complete.
        "$VS2008_DEVENV_PATH" "$ProjName".vcproj "$VSMakeRule" "$VsBuildConfig" /out "$VMakeErrFile" || true
        
		# turn off output enabled above
		set +x 

        # Note:  noop to generate error file - done by devenv with above command  
        
        # make copy of error file for vim's use (and auto deletion)
        cp "$ProjDir/$VMakeErrFile" "${ProjDir}/${VMakeErrFileTmp}"
    
	elif [ "$IsEclipseProj" == true ]; then
		
		# Run CCS6 cmd line compiler
		# Rules accepted:
		#  all (default)
		#  clean		- passed to compiler
		#  info			- runs default build, generates buildinfo if successful	
		#
		#  any other rules are passed on to compiler
		
		BuildErr=true
     
		if [ "$IsCCSProj" == true ]; then
			# The following script must be executed from the directory containing the
			# makefile, not the project root directory. 
			cd Debug
			
			# use gmake for CCS projects, similar to CCS ide

			if [[ $ShellPlatform == 'cygwin' ]]; then

				# Note:  mspmake.bat's directory must be in Windows path
				# ie C:\cygwin64\home\<USER>\dotfiles\cmd
				if mspmake.bat $MakeRules; then
					BuildErr=false	
				fi

			else
				# set flags passed into compiler via environment variable
				export MSP430_C_OPTION="$TiCompilerOptions"

				set -x
				if /Applications/ti/ccsv6/utils/bin/gmake -k "$MakeRules"; then
					BuildErr=false
				fi
				set +x
			fi
        	
			cd ..
			
			# generate brief info on build to stdout
			vmakeGenBuildInfoMsp.sh -o

		else
			# use make for eclipse projects, similar to eclipse ide
			
			VMakeErrPath="${ProjDir}/${VMakeErrFile}"
			
			echo "make -w -C ${ProjDir}/Debug $MakeRules" 
			# build the project, passing make directory of project's Makefile.  
			# have make print directory info, so vim's quickfix can locate source files from error file
			# send output to screen and error file
			if make -w -C "${ProjDir}/Debug" "$MakeRules" 2>&1 | tee "$VMakeErrPath"; then
				BuildErr=false
			fi

        	# make copy of error file for vim's use (and auto deletion)
        	cp "$VMakeErrPath" "${ProjDir}/${VMakeErrFileTmp}"
    
		fi

    elif [ "$IsArduinoProj" == true ]; then

		set -x
		/Applications/Arduino.app/Contents/MacOS/Arduino --verify *.ino	
		set +x
    
	elif [ "$IsMakefileProj" == true ]; then

		set -x
		make $MakeRules
		set +x
	
	else

		echo "Unknown project type!"
    
	fi

    #always regenerate tags following make
    vmakeGenTagFile.sh 
			
	# generate buildinfo if rule is present and build was successful
	if [ "$FlgGenBuildInfo" == true ] && [ "$BuildErr" == false ]; then
		if [ "$IsCCSProj" == true ]; then
			# if $BuildLabel is not set, call with no params to use default label
			if [[ -z "${BuildLabel// }" ]]; then
				vmakeGenBuildInfoMsp.sh 
			else
				vmakeGenBuildInfoMsp.sh -L "$BuildLabel"
			fi
		# to get eclipse to generate map file:
		# project properties->C/C++ Build->Settings->MacOS X C++ Linker->Miscellaneous->Linker flags:
		#	-Wl,-map,${ProjName}.map
		else
			echo "build info not implemented for this project type"

		fi
	fi

fi

if [ "$FlgGenErrs" == true ]; then

	if [ "$IsCCSProj" == true ]; then
		vmakeGenErrFileCCS.sh 

	# non CCS projects have nothing to do in this step, errorfile is generated with build step
	else
		if [ "$FlgGenErrsOnly" == true ]; then
			echo "vmake err - noop for project type. rebuild to generate error file"
		fi

        # ensure file exists so vim doesnt error out
        touch "$VMakeErrFileTmp"
	fi
fi

# return to original directory (in case it changed)
cd "$OrigDir"
